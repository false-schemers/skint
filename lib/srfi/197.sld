;[esl] adapted from the reference implementation by Adam R. Nelson

;;; SPDX-FileCopyrightText: 2020 Adam R. Nelson <adam@nels.onl>
;;;
;;; SPDX-License-Identifier: MIT

(define-library (srfi 197)

(import (scheme base) (srfi 2))
(export chain chain-and chain-when chain-lambda nest nest-reverse)

(begin

(define-syntax chain
  (syntax-rules etc1 ()
    ((_ initial-value) initial-value)
    ((_ initial-value (step etc1) etc1)
      (chain initial-value _ ... (step etc1) etc1))
    ((_ initial-value placeholder (step etc1) etc1)
      (chain initial-value placeholder ... (step etc1) etc1))
    ((_ initial-value placeholder ellipsis (first-step etc1) (next-step etc1) etc1)
      (let ()
        (define-syntax %chain
          (syntax-rules etc2 (placeholder ellipsis)
            ; (_ in-step out-step in-vars out-vars in-steps out-steps)
            ((_ () () () ((var) etc2) () (step etc2 last-step))
              (let* ((var step) etc2) last-step))
            ((_ () () () (vars etc2) () (step etc2 last-step))
              (let*-values ((vars step) etc2) last-step))
            ((_ () () () out-vars (step . in-steps) out-steps)
              (%chain step () () out-vars in-steps out-steps))
            ((_ () step () (out-vars etc2) in-steps (out-steps etc2))
              (%chain () () () (out-vars etc2 ignored) in-steps (out-steps etc2 step)))
            ((_ () step vars (out-vars etc2) in-steps (out-steps etc2))
              (%chain () () () (out-vars etc2 vars) in-steps (out-steps etc2 step)))
            ((_ (placeholder ellipsis) (step etc2) () (out-vars etc2) in-steps (out-steps etc2))
              (%chain () () () (out-vars etc2 chain-rest-var) in-steps (out-steps etc2 (apply step etc2 chain-rest-var))))
            ((_ (placeholder ellipsis) (step etc2) (vars etc2) (out-vars etc2) in-steps (out-steps etc2))
              (%chain () () () (out-vars etc2 (vars etc2 . chain-rest-var)) in-steps (out-steps etc2 (apply step etc2 chain-rest-var))))
            ((_ (placeholder ellipsis . rest) . _)
              (syntax-error "_ ... can only be used as a final argument"))
            ((_ (placeholder . in-step) (out-step etc2) (vars etc2) . rest)
              (%chain in-step (out-step etc2 chain-var) (vars etc2 chain-var) . rest))
            ((_ (x . in-step) (out-step etc2) . rest)
              (%chain in-step (out-step etc2 x) . rest))))
        (%chain (first-step etc1) () () () ((next-step etc1) etc1) (initial-value))))))

(define-syntax chain-and
  (syntax-rules etc1 ()
    ((_ initial-value) initial-value)
    ((_ initial-value (step etc1) etc1) (chain-and initial-value _ (step etc1) etc1))
    ((_ initial-value placeholder (first-step etc1) (next-step etc1) etc1)
      (let ()
        (define-syntax %chain-and
          (syntax-rules etc2 (placeholder)
            ; (_ in-step out-step in-vars out-vars in-steps out-steps)
            ((_ () () () (var etc2) () (step etc2 last-step))
              (and-let* ((var step) etc2) last-step))
            ((_ () () () out-vars (step . in-steps) out-steps)
              (%chain-and step () () out-vars in-steps out-steps))
            ((_ () step () (out-vars etc2) in-steps (out-steps etc2))
              (%chain-and () () () (out-vars etc2 ignored) in-steps (out-steps etc2 step)))
            ((_ () step (var) (out-vars etc2) in-steps (out-steps etc2))
              (%chain-and () () () (out-vars etc2 var) in-steps (out-steps etc2 step)))
            ((_ (placeholder . in-step) (out-step etc2) () . rest)
              (%chain-and in-step (out-step etc2 chain-var) (chain-var) . rest))
            ((_ (placeholder . excess) . rest)
              (syntax-error "chain-and does not support multiple _ in a single step"))
            ((_ (x . in-step) (out-step etc2) . rest)
              (%chain-and in-step (out-step etc2 x) . rest))))
        (%chain-and (first-step etc1) () () () ((next-step etc1) etc1) (initial-value))))))

(define-syntax chain-when
  (syntax-rules etc1 ()
    ((_ initial-value) initial-value)
    ((_ initial-value (guard? (step etc1)) etc1)
      (chain-when initial-value _ (guard? (step etc1)) etc1))
    ((_ initial-value placeholder (first-guard? (first-step etc1)) (next-guard? (next-step etc1)) etc1)
      (let ()
        (define-syntax %chain-when
          (syntax-rules etc2 (placeholder)
            ; (_ in-step out-step guard? chain-var in-steps out-expr)
            ((_ () () _1 _2 () out-expr) out-expr)
            ((_ () () _1 _2 ((guard? step) . in-steps) out-expr)
              (%chain-when step () guard? #f in-steps out-expr))
            ((_ () step guard? #f in-steps out-expr)
              (%chain-when () () #f #f in-steps
                (let ((chain-var out-expr))
                  (if guard? step chain-var))))
            ((_ () step guard? chain-var in-steps out-expr)
              (%chain-when () () #f #f in-steps
                (let ((chain-var out-expr))
                  (if guard? step chain-var))))
            ((_ (placeholder . in-step) (out-step etc2) guard? #f . rest)
              (%chain-when in-step (out-step etc2 chain-var) guard? chain-var . rest))
            ((_ (placeholder . excess) . rest)
              (syntax-error "chain-when does not support multiple _ in a single step"))
            ((_ (x . in-step) (out-step etc2) . rest)
              (%chain-when in-step (out-step etc2 x) . rest))))
        (%chain-when (first-step etc1) () first-guard? #f ((next-guard? (next-step etc1)) etc1) initial-value)))))

(define-syntax chain-lambda
  (syntax-rules etc1 ()
    ((_ (step etc1) etc1) (chain-lambda _ ... (step etc1) etc1))
    ((_ placeholder (step etc1) etc1) (chain-lambda placeholder ... (step etc1) etc1))
    ((_ placeholder ellipsis (first-step etc1) (next-step etc1) etc1)
      (let ()
        (define-syntax %chain-lambda
          (syntax-rules etc2 (placeholder ellipsis)
            ; (_ in-step out-step args rest-of-steps)
            ((_ () step args ())
              (lambda args step))
            ((_ () step args steps)
              (lambda args
                (chain step placeholder ellipsis . steps)))
            ((_ (placeholder ellipsis) (step etc2) () ())
              (lambda chain-rest-var (apply step etc2 chain-rest-var)))
            ((_ (placeholder ellipsis) (step etc2) () steps)
              (lambda chain-rest-var
                (chain (apply step etc2 chain-rest-var) placeholder ellipsis . steps)))
            ((_ (placeholder ellipsis) (step etc2) (args etc2) ())
              (lambda (args etc2 . chain-rest-var) (apply step etc2 chain-rest-var)))
            ((_ (placeholder ellipsis) (step etc2) (args etc2) steps)
              (lambda (args etc2 . chain-rest-var)
                (chain (apply step etc2 chain-rest-var) placeholder ellipsis . steps)))
            ((_ (placeholder ellipsis . excess) . rest)
              (syntax-error "_ ... can only be used as a final argument"))
            ((_ (placeholder . in-step) (out-step etc2) (args etc2) . rest)
              (%chain-lambda in-step (out-step etc2 chain-var) (args etc2 chain-var) . rest))
            ((_ (x . in-step) (out-step etc2) . rest)
              (%chain-lambda in-step (out-step etc2 x) . rest))))
        (%chain-lambda (first-step etc1) () () ((next-step etc1) etc1))))))

(define-syntax nest
  (syntax-rules etc1 (_)
    ((nest last) last)
    ((nest (step etc1) etc1 last) (nest _ (step etc1) etc1 last))
    ((nest placeholder (extra-step etc1) etc1 (first-step etc1) last)
      (let ()
        ; let-syntax is buggy in some Schemes, define-syntax is more reliable
        (define-syntax %nest
          (syntax-rules etc2 (placeholder)
            ((%nest result () placeholder ()) result)
            ((%nest result () placeholder (rest etc2 step))
              (%nest () step result (rest etc2)))
            ((%nest result () accum steps)
              (syntax-error "nest: step must contain _"))
            ((%nest result (placeholder . rest) placeholder steps)
              (syntax-error "nest: only one _ allowed per step"))
            ((%nest (result etc2) (placeholder . rest) accum steps)
              (%nest (result etc2 accum) rest placeholder steps))
            ((%nest (result etc2) (element . rest) accum steps)
              (%nest (result etc2 element) rest accum steps))))
        (%nest () (first-step etc1) last ((extra-step etc1) etc1))))
    ((nest placeholder last) last)))

(define-syntax nest-reverse
  (syntax-rules etc1 (_)
    ((nest-reverse first) first)
    ((nest-reverse first (step etc1) etc1) (nest-reverse first _ (step etc1) etc1))
    ((nest-reverse first placeholder (first-step etc1) (extra-step etc1) etc1)
      (let ()
        (define-syntax %nest
          (syntax-rules etc2 (placeholder)
            ((%nest result () placeholder ()) result)
            ((%nest result () placeholder (step . rest))
              (%nest () step result rest))
            ((%nest result () accum steps)
              (syntax-error "nest-reverse: step must contain _"))
            ((%nest result (placeholder . rest) placeholder steps)
              (syntax-error "nest-reverse: only one _ allowed per step"))
            ((%nest (result etc2) (placeholder . rest) accum steps)
              (%nest (result etc2 accum) rest placeholder steps))
            ((%nest (result etc2) (element . rest) accum steps)
              (%nest (result etc2 element) rest accum steps))))
        (%nest () (first-step etc1) first ((extra-step etc1) etc1))))
    ((nest-reverse first placeholder) first)))

))
