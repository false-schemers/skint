(import (srfi 160 base) (srfi 160 u16) (srfi 160 s16) (srfi 128))
(include "test.scm")

(test-begin "srfi-160")

;; tests from SRFI-4

(test #t (u8vector? #u8()))
(test #t (u8vector? #u8(0 1 2)))
(test #f (u8vector? #()))
(test #f (u8vector? #(0 1 2)))
(test #f (u8vector? '()))
(test #t (u8vector? (make-u8vector 0)))
(test 0 (u8vector-length (make-u8vector 0)))
(test 1024 (u8vector-length (make-u8vector 1024)))
(test 1024 (u8vector-length (make-u8vector 1024 255)))
(test 3 (u8vector-length (u8vector 0 1 2)))
(test 0 (u8vector-ref (u8vector 0 1 2) 0))
(test 1 (u8vector-ref (u8vector 0 1 2) 1))
(test 2 (u8vector-ref (u8vector 0 1 2) 2))
(test #u8(0 255 2) (let ((bv (u8vector 0 1 2))) (u8vector-set! bv 1 255) bv))
(test '() (u8vector->list #u8()))
(test '(0 1 2) (u8vector->list #u8(0 1 2)))
(test '(0 1 2) (u8vector->list #u8(0 1 2) 0))
(test '(0 1 2) (u8vector->list #u8(0 1 2) 0 3))
(test '(1 2) (u8vector->list #u8(0 1 2) 1))
(test '(1) (u8vector->list #u8(0 1 2) 1 2))
(test '() (u8vector->list #u8(0 1 2) 2 2))
(test #u8() (list->u8vector '()))
(test #u8(24 42) (list->u8vector '(24 42)))

(test #t (s8vector? #s8()))
(test #t (s8vector? #s8(0 1 2)))
(test #f (s8vector? #()))
(test #f (s8vector? #(0 1 2)))
(test #f (s8vector? '()))
(test #t (s8vector? (make-s8vector 0)))
(test 0 (s8vector-length (make-s8vector 0)))
(test 1024 (s8vector-length (make-s8vector 1024)))
(test 1024 (s8vector-length (make-s8vector 1024 127)))
(test 3 (s8vector-length (s8vector 0 1 2)))
(test 0 (s8vector-ref (s8vector 0 1 2) 0))
(test 1 (s8vector-ref (s8vector 0 1 2) 1))
(test 2 (s8vector-ref (s8vector 0 1 2) 2))
(test #s8(0 -128 2) (let ((bv (s8vector 0 1 2))) (s8vector-set! bv 1 -128) bv))
(test '() (s8vector->list #s8()))
(test '(0 1 2) (s8vector->list #s8(0 1 2)))
(test '(0 1 2) (s8vector->list #s8(0 1 2) 0))
(test '(0 1 2) (s8vector->list #s8(0 1 2) 0 3))
(test '(1 2) (s8vector->list #s8(0 1 2) 1))
(test '(1) (s8vector->list #s8(0 1 2) 1 2))
(test '() (s8vector->list #s8(0 1 2) 2 2))
(test #s8() (list->s8vector '()))
(test #s8(24 42) (list->s8vector '(24 42)))

(test #t (u16vector? #u16()))
(test #t (u16vector? #u16(0 1 2)))
(test #f (u16vector? #()))
(test #f (u16vector? #(0 1 2)))
(test #f (u16vector? '()))
(test #t (u16vector? (make-u16vector 0)))
(test 0 (u16vector-length (make-u16vector 0)))
(test 1024 (u16vector-length (make-u16vector 1024)))
(test 1024 (u16vector-length (make-u16vector 1024 65535)))
(test 3 (u16vector-length (u16vector 0 1 2)))
(test 0 (u16vector-ref (u16vector 0 1 2) 0))
(test 1 (u16vector-ref (u16vector 0 1 2) 1))
(test 2 (u16vector-ref (u16vector 0 1 2) 2))
(test #u16(0 65535 2) (let ((bv (u16vector 0 1 2))) (u16vector-set! bv 1 65535) bv))
(test '() (u16vector->list #u16()))
(test '(0 1 2) (u16vector->list #u16(0 1 2)))
(test '(0 1 2) (u16vector->list #u16(0 1 2) 0))
(test '(0 1 2) (u16vector->list #u16(0 1 2) 0 3))
(test '(1 2) (u16vector->list #u16(0 1 2) 1))
(test '(1) (u16vector->list #u16(0 1 2) 1 2))
(test '() (u16vector->list #u16(0 1 2) 2 2))
(test #u16() (list->u16vector '()))
(test #u16(24 42) (list->u16vector '(24 42)))

(test #t (s16vector? #s16()))
(test #t (s16vector? #s16(0 1 2)))
(test #f (s16vector? #()))
(test #f (s16vector? #(0 1 2)))
(test #f (s16vector? '()))
(test #t (s16vector? (make-s16vector 0)))
(test 0 (s16vector-length (make-s16vector 0)))
(test 1024 (s16vector-length (make-s16vector 1024)))
(test 1024 (s16vector-length (make-s16vector 1024 -32768)))
(test 3 (s16vector-length (s16vector 0 1 2)))
(test 0 (s16vector-ref (s16vector 0 1 2) 0))
(test 1 (s16vector-ref (s16vector 0 1 2) 1))
(test 2 (s16vector-ref (s16vector 0 1 2) 2))
(test #s16(0 -32768 2) (let ((bv (s16vector 0 1 2))) (s16vector-set! bv 1 -32768) bv))
(test '() (s16vector->list #s16()))
(test '(0 1 2) (s16vector->list #s16(0 1 2)))
(test '(0 1 2) (s16vector->list #s16(0 1 2) 0))
(test '(0 1 2) (s16vector->list #s16(0 1 2) 0 3))
(test '(1 2) (s16vector->list #s16(0 1 2) 1))
(test '(1) (s16vector->list #s16(0 1 2) 1 2))
(test '() (s16vector->list #s16(0 1 2) 2 2))
(test #s16() (list->s16vector '()))
(test #s16(24 42) (list->s16vector '(24 42)))

(test #t (f32vector? #f32()))
(test #t (f32vector? #f32(0.0 1.0 2.0)))
(test #f (f32vector? #()))
(test #f (f32vector? #(-inf.0 +inf.0 +nan.0)))
(test #f (f32vector? '()))
(test #t (f32vector? (make-f32vector 0)))
(test 0 (f32vector-length (make-f32vector 0)))
(test 1024 (f32vector-length (make-f32vector 1024)))
(test 1024 (f32vector-length (make-f32vector 1024 +inf.0)))
(test 3 (f32vector-length (f32vector 0.0 1.0 2.0)))
(test 0.0 (f32vector-ref (f32vector 0.0 1.0 2.0) 0))
(test 1.0 (f32vector-ref (f32vector 0.0 1.0 2.0) 1))
(test 2.0 (f32vector-ref (f32vector 0.0 1.0 2.0) 2))
(test #f32(-0.0 +inf.0 -2.0) (let ((bv (f32vector -0.0 1.0 -2.0))) (f32vector-set! bv 1 +inf.0) bv))
(test '() (f32vector->list #f32()))
(test '(0.0 1.0 2.0) (f32vector->list #f32(0.0 1.0 2.0)))
(test '(0.0 1.0 2.0) (f32vector->list #f32(0.0 1.0 2.0) 0))
(test '(0.0 1.0 2.0) (f32vector->list #f32(0.0 1.0 2.0) 0 3))
(test '(1.0 2.0) (f32vector->list #f32(0.0 1.0 2.0) 1))
(test '(1.0) (f32vector->list #f32(0.0 1.0 2.0) 1 2))
(test '() (f32vector->list #f32(0.0 1.0 2.0) 2 2))
(test #f32() (list->f32vector '()))
(test #f32(24.0 42.0) (list->f32vector '(24.0 42.0)))
(test -inf.0 (f32vector-ref (f32vector -inf.0 +inf.0 +nan.0) 0))
(test +inf.0 (f32vector-ref (f32vector -inf.0 +inf.0 +nan.0) 1))
(test +nan.0 (f32vector-ref (f32vector -inf.0 +inf.0 +nan.0) 2))
(test 2.0 (f32vector-ref #f32(2.0000000009) 0))
(test +inf.0 (f32vector-ref #f32(1.79769313486231e308) 0))
(test -0.0 (f32vector-ref #f32(-2.225074e-308) 0))

(test #t (f64vector? #f64()))
(test #t (f64vector? #f64(0.0 1.0 2.0)))
(test #f (f64vector? #()))
(test #f (f64vector? #(-inf.0 +inf.0 +nan.0)))
(test #f (f64vector? '()))
(test #t (f64vector? (make-f64vector 0)))
(test 0 (f64vector-length (make-f64vector 0)))
(test 1024 (f64vector-length (make-f64vector 1024)))
(test 1024 (f64vector-length (make-f64vector 1024 +inf.0)))
(test 3 (f64vector-length (f64vector 0.0 1.0 2.0)))
(test 0.0 (f64vector-ref (f64vector 0.0 1.0 2.0) 0))
(test 1.0 (f64vector-ref (f64vector 0.0 1.0 2.0) 1))
(test 2.0 (f64vector-ref (f64vector 0.0 1.0 2.0) 2))
(test #f64(-0.0 +inf.0 -2.0) (let ((bv (f64vector -0.0 1.0 -2.0))) (f64vector-set! bv 1 +inf.0) bv))
(test '() (f64vector->list #f64()))
(test '(0.0 1.0 2.0) (f64vector->list #f64(0.0 1.0 2.0)))
(test '(0.0 1.0 2.0) (f64vector->list #f64(0.0 1.0 2.0) 0))
(test '(0.0 1.0 2.0) (f64vector->list #f64(0.0 1.0 2.0) 0 3))
(test '(1.0 2.0) (f64vector->list #f64(0.0 1.0 2.0) 1))
(test '(1.0) (f64vector->list #f64(0.0 1.0 2.0) 1 2))
(test '() (f64vector->list #f64(0.0 1.0 2.0) 2 2))
(test #f64() (list->f64vector '()))
(test #f64(24.0 42.0) (list->f64vector '(24.0 42.0)))
(test -inf.0 (f64vector-ref (f64vector -inf.0 +inf.0 +nan.0) 0))
(test +inf.0 (f64vector-ref (f64vector -inf.0 +inf.0 +nan.0) 1))
(test +nan.0 (f64vector-ref (f64vector -inf.0 +inf.0 +nan.0) 2))
(test 2.0000000009 (f64vector-ref #f64(2.0000000009) 0))
(test 1.79769313486231e308 (f64vector-ref #f64(1.79769313486231e308) 0))
(test -2.225074e-308 (f64vector-ref #f64(-2.225074e-308) 0))

;; Tests for predicates

(test #f (u8? 'a))
(test #f (u8? -1))
(test #f (u8? 1000))
(test #t (u8? 0))
(test #t (u8? 255))
(test #f (s8? 'a))
(test #t (s8? -128))
(test #f (s8? 255))
(test #t (s8? 127))
(test #t (s8? 0))

(test #f (u16? 'a))
(test #f (u16? -1))
(test #f (u16? 1000000))
(test #t (u16? 0))
(test #t (u16? 65535))
(test #f (s16? 'a))
(test #t (s16? -32768))
(test #f (s16? 65535))
(test #t (s16? 32767))
(test #t (s16? 0))

(test #f (f32? 'a))
(test #f (f32? -1))
(test #f (f32? 1000000))
(test #t (f32? 0.0))
(test #t (f32? -0.0))
(test #t (f32? -inf.0))
(test #t (f32? +inf.0))
(test #t (f32? +nan.0))
(test #t (f32? 1.79769313486231e308))
(test #t (f32? -2.225074e-308))

(test #f (f64? 'a))
(test #f (f64? -1))
(test #f (f64? 1000000))
(test #t (f64? 0.0))
(test #t (f64? -0.0))
(test #t (f64? -inf.0))
(test #t (f64? +inf.0))
(test #t (f64? +nan.0))
(test #t (f64? 1.79769313486231e308))
(test #t (f64? -2.225074e-308))

;; Tests adapted from Chibi (originally by Alex Shinn)

(define a2i '#u16(0 1 2 3 4 5 6 7 8))
(test '#u8(0 1 2 3 4) (u8vector 0 1 2 3 4))
(test '#u16(0 1 2 3 4) (u16vector 0 1 2 3 4))
(test '#u16(0 1 2 3 4 5 6 7 8 9)
  (u16vector-unfold (lambda (i x) (values x (+ x 1))) 10 0))
(test '#u16(0 1 2 3 4 5 6) (u16vector-unfold values 7 #f))
(test a2i (u16vector-copy a2i))
(test-assert (not (eqv? a2i (u16vector-copy a2i))))
(test '#u16(6 7 8) (u16vector-copy a2i 6))
(test '#u16(3 4 5) (u16vector-copy a2i 3 6))
(test '#u16(4 3 1) (u16vector-reverse-copy (u16vector 1 3 4)))
(test '#u16(1 2 3 4) (u16vector-reverse-copy '#u16(5 4 3 2 1 0) 1 5))
(test '(#u16(#x01 #x02) #u16(#x03 #x04))
    (u16vector-segment #u16(1 2 3 4) 2))
(test '#u16(0 1) (u16vector-append '#u16(0) '#u16(1)))
(test '#u16(0 1 2 3) (u16vector-append '#u16(0) '#u16(1 2 3)))
(test '#u16(0 1 2 3) (u16vector-append '#u16(0) '#u16(1 2 3)))
(test '#s16(0 -1 2 -3) (s16vector-append '#s16(0) '#s16(-1 2 -3)))
(test '#u16(0 1 2 3) (u16vector-concatenate '(#u16(0 1) #u16(2 3))))
(test '#u16(0 1 6 7)
  (u16vector-append-subvectors '#u16(0 1 2 3 4) 0 2 '#u16(4 5 6 7 8) 2 4))
(test '#u16(1 2)
  (vector->u16vector '#(0 1 2 3) 1 3))
(test '#(1 2)
  (u16vector->vector '#u16(0 1 2 3) 1 3))

(test #f (u16vector-empty? '#u16(0)))
(test-assert (u16vector-empty? '#u16()))
(test-assert (u16vector= '#u16(0 1 2 3) '#u16(0 1 2 3)))
(test #t (u16vector= '#u16(0 1 2 3) '#u16(0 1 2 3)))
(test #f (u16vector= '#u16(1 2 3 4 5) '#u16(1 2 3 4)))
(test-assert (u16vector=))
(test-assert (u16vector= '#u16(0)))
(test-assert (u16vector= (u16vector 0) (u16vector 0)))

(define vec '#u16(0 1 2 3 4 5))
(define vec2 (u16vector 0 1 2 3 4))
(define vec3 (u16vector 1 2 3 4 5))
(test '(5 4 3 2 1 0)
    (u16vector-fold (lambda (tail elt) (cons elt tail)) '() vec))
(test 3 (u16vector-fold (lambda (ctr n) (if (even? n) (+ ctr 1) ctr)) 0 vec))
(test '(0 1 2 3) (u16vector-fold-right (lambda (tail elt) (cons elt tail))
                                        '() '#u16(0 1 2 3)))
(test '#u16(1 4 9 16) (u16vector-map square '#u16(1 2 3 4)))
(test '#u16(5 8 9 8 5) (u16vector-map * '#u16(1 2 3 4 5) '#u16(5 4 3 2 1)))
(u16vector-map! square vec2)
(test '#u16(0 1 4 9 16) (u16vector-copy vec2))
(u16vector-map! * vec2 vec3)
(test '#u16(0 2 12 36 80) (u16vector-copy vec2))
(let ((result '()))
  (u16vector-for-each (lambda (x) (set! result (cons x result))) vec)
  (test '(5 4 3 2 1 0) result))
(test 3 (u16vector-count even? '#u16(3 1 4 1 5 9 2 5 6)))
(test 2 (u16vector-count < '#u16(1 3 6 9) '#u16(2 4 6 8 10 12)))
(test '#u16(3 4 8 9 14 23 25 30 36) (u16vector-cumulate + 0 '#u16(3 1 4 1 5 9 2 5 6)))

(define v '#u16(0 2 4 6 8 10 12))
(test 2 (u16vector-index even? '#u16(3 1 4 1 5 9 6)))
(test 5 (u16vector-index-right odd? '#u16(3 1 4 1 5 9 6)))
(test 2 (u16vector-skip odd? '#u16(1 3 2 5 7 1 1 8 9)))
(test 7 (u16vector-skip-right odd? '#u16(1 3 2 5 7 1 1 8 9)))
(test-assert (u16vector-any even? '#u16(1 2 3 4 5)))
(test-assert (u16vector-any < '#u16(1 2 3 4 5) '#u16(2 1 3 4 5)))
(test #f (u16vector-any odd? '#u16(2 4 6 8)))
(test #f (u16vector-any > '#u16(1 2 3 4 5) '#u16(1 2 3 4 5)))
(test #f (u16vector-every odd? '#u16(1 2 3 4 5)))
(test-assert (u16vector-every number? '#u16(1 2 3 4 5)))
(test #f (u16vector-every < '#u16(1 2 3) '#u16(2 3 3)))
(test-assert (u16vector-every < '#u16(1 2 3) '#u16(2 3 4)))
(test 'yes (u16vector-any (lambda (x) (if (even? x) 'yes #f)) '#u16(1 3 2 5 7)))
(let-values (((new off) (u16vector-partition odd? '#u16(1 2 3 4 5 6))))
  (test '#u16(1 3 5 2 4 6) (u16vector-copy new))
  (test 3 off))

(define vs (u16vector 1 2 3))
(define vf0 (u16vector 1 2 3))
(define vf1 (u16vector 1 2 3))
(define vf2 (u16vector 1 2 3))
(define vr0 (u16vector 1 2 3))
(define vr1 (u16vector 1 2 3))
(define vr2 (u16vector 1 2 3))
(define vc0 (u16vector 1 2 3 4 5))
(define vc1 (u16vector 1 2 3 4 5))
(define vc2 (u16vector 1 2 3 4 5))
(define vrc0 (u16vector 1 2 3 4 5))
(define vrc1 (u16vector 1 2 3 4 5))
(define vrc2 (u16vector 1 2 3 4 5))
(define vu0 (u16vector 1 2 3 4 5))
(define vu1 (u16vector 1 2 3 4 5))
(define vu2 (u16vector 1 2 3 4 5))
(define vur0 (u16vector 1 2 3 4 5))
(define vur1 (u16vector 1 2 3 4 5))
(define vur2 (u16vector 1 2 3 4 5))
(u16vector-swap! vs 0 1)
(test '#u16(2 1 3) (u16vector-copy vs))
(u16vector-fill! vf0 0)
(test '#u16(0 0 0) (u16vector-copy vf0))
(u16vector-fill! vf1 0 1)
(test '#u16(1 0 0) (u16vector-copy vf1))
(u16vector-fill! vf2 0 0 1)
(test '#u16(0 2 3) (u16vector-copy vf2))
(u16vector-reverse! vr0)
(test '#u16(3 2 1) (u16vector-copy vr0))
(u16vector-reverse! vr1 1)
(test '#u16(1 3 2) (u16vector-copy vr1))
(u16vector-reverse! vr2 0 2)
(test '#u16(2 1 3) (u16vector-copy vr2))
(u16vector-copy! vc0 1 '#u16(10 20 30))
(test '#u16(1 10 20 30 5) (u16vector-copy vc0))
(u16vector-copy! vc1 1 '#u16(0 10 20 30 40) 1)
(test '#u16(1 10 20 30 40) (u16vector-copy vc1))
(u16vector-copy! vc2 1 '#u16(0 10 20 30 40) 1 4)
(test '#u16(1 10 20 30 5) (u16vector-copy vc2))
(u16vector-reverse-copy! vrc0 1 '#u16(10 20 30))
(test '#u16(1 30 20 10 5) (u16vector-copy vrc0))
(u16vector-reverse-copy! vrc1 1 '#u16(0 10 20 30 40) 1)
(test '#u16(1 40 30 20 10) (u16vector-copy vrc1))
(u16vector-reverse-copy! vrc2 1 '#u16(0 10 20 30 40) 1 4)
(test '#u16(1 30 20 10 5) (u16vector-copy vrc2))
(let ((uv (make-u16vector 2 0)))
  (u16vector-set! uv 0 10631)
  (test '#u16(10631 0) uv))

(test '(1 2 3) (u16vector->list '#u16(1 2 3)))
(test '(2 3) (u16vector->list '#u16(1 2 3) 1))
(test '(1 2) (u16vector->list '#u16(1 2 3) 0 2))
(test '#u16(1 2 3) (list->u16vector '(1 2 3)))
(test '(3 2 1) (reverse-u16vector->list '#u16(1 2 3)))
(test '(3 2) (reverse-u16vector->list '#u16(1 2 3) 1))
(test '(2 1) (reverse-u16vector->list '#u16(1 2 3) 0 2))
(test '#u16(3 2 1) (reverse-list->u16vector '(1 2 3)))

;;; SPDX-FileCopyrightText: 2018 John Cowan <cowan@ccil.org>
;;;
;;; SPDX-License-Identifier: MIT

(define (times2 x) (* x 2))
(define s5 (s16vector 1 2 3 4 5))
(define s4 (s16vector 1 2 3 4))
(define s5+ (s16vector 1 2 3 4 6))

(define (steady i x) (values x x))
(define (count-up i x) (values x (+ x 1)))
(define (count-down i x) (values x (- x 1)))
(define (odd+1 x) (if (odd? x) (+ 1 x) #f))
(define s16vector< (comparator-ordering-predicate s16vector-comparator))
(define s16vector-hash (comparator-hash-function s16vector-comparator))

(define g (make-s16vector-generator s5))
(define-syntax test-equiv
  (syntax-rules ()
    ((test-equiv expect expr)
     (test expect (s16vector->list expr)))
    ((test-equiv name expect expr)
     (test name expect (s16vector->list expr)))))

(test-equiv "make" '(3 3 3 3 3) (make-s16vector 5 3))
(test-equiv "s16vector" '(-2 -1 0 1 2) (s16vector -2 -1 0 1 2))
(test-equiv "unfold up" '(10 11 12 13 14)
            (s16vector-unfold count-up 5 10))
(test-equiv "unfold down" '(10 9 8 7 6)
            (s16vector-unfold count-down 5 10))
(test-equiv "unfold steady" '(10 10 10 10 10)
            (s16vector-unfold steady 5 10))
(test-equiv "unfold-right up" '(14 13 12 11 10)
            (s16vector-unfold-right count-up 5 10))
(test-equiv "unfold-right down" '(6 7 8 9 10)
            (s16vector-unfold-right count-down 5 10))
(test-equiv "unfold-right steady" '(10 10 10 10 10)
            (s16vector-unfold-right steady 5 10))
(test-equiv "copy" '(1 2 3 4 5) (s16vector-copy s5))
(test-assert "copy2" (not (eqv? s5 (s16vector-copy s5))))
(test-equiv "copy3" '(2 3) (s16vector-copy s5 1 3))
(test-equiv "reverse-copy" '(5 4 3 2 1) (s16vector-reverse-copy s5))
(test-equiv "append" '(1 2 3 4 5 1 2 3 4 5)
            (s16vector-append s5 s5))
(test-equiv "concatenate" '(1 2 3 4 5 1 2 3 4 5)
            (s16vector-concatenate (list s5 s5)))
(test-equiv "append-subvectors" '(2 3 2 3)
            (s16vector-append-subvectors s5 1 3 s5 1 3))

(test-assert "s16?" (s16? 5))
(test-assert "not s16?" (not (s16? 65536)))
(test-assert "s16vector?" (s16vector? s5))
(test-assert "not s16vector?" (not (s16vector? #t)))
(test-assert "empty" (s16vector-empty? (s16vector)))
(test-assert "not empty" (not (s16vector-empty? s5)))
(test-assert "=" (s16vector= (s16vector 1 2 3) (s16vector 1 2 3)))
(test-assert "= multi" (s16vector= (s16vector 1 2 3)
                                    (s16vector 1 2 3)
                                    (s16vector 1 2 3)))
(test-assert "not =" (not (s16vector= (s16vector 1 2 3) (s16vector 3 2 1))))
(test-assert "not =2" (not (s16vector= (s16vector 1 2 3) (s16vector 1 2))))
(test-assert "not = multi" (not (s16vector= (s16vector 1 2 3)
                                            (s16vector 1 2 3)
                                            (s16vector 3 2 1))))

(test "ref" 1 (s16vector-ref (s16vector 1 2 3) 0))
(test "length" 3 (s16vector-length (s16vector 1 2 3)))

(test-equiv "take" '(1 2) (s16vector-take s5 2))
(test-equiv "take-right" '(4 5) (s16vector-take-right s5 2))
(test-equiv "drop" '(3 4 5) (s16vector-drop s5 2))
(test-equiv "drop-right" '(1 2 3) (s16vector-drop-right s5 2))
(test "segment" (list (s16vector 1 2 3) (s16vector 4 5))
      (s16vector-segment s5 3))
(test "fold" -6 (s16vector-fold - 0 (s16vector 1 2 3)))
(test "fold" '(((0 1 4) 2 5) 3 6)
      (s16vector-fold list 0 (s16vector 1 2 3) (s16vector 4 5 6)))
(test "fold-right" -6 (s16vector-fold-right - 0 (s16vector 1 2 3)))
(test "fold-right" '(((0 3 6) 2 5) 1 4)
      (s16vector-fold-right list 0 (s16vector 1 2 3) (s16vector 4 5 6)))
(test-equiv "map" '(-1 -2 -3 -4 -5) (s16vector-map - s5))
(test-equiv "map" '(-2 -4 -6 -8 -10) (s16vector-map - s5 s5 s5 s5))
(let ((v (s16vector 1 2 3 4 5)))
  (s16vector-map! - v)
  (test-equiv "map!" '(-1 -2 -3 -4 -5) v))
(let ((v (s16vector 1 2 3 4 5))
      (v2 (s16vector 6 7 8 9 10)))
  (s16vector-map! + v v2)
  (test-equiv "map!" '(7 9 11 13 15) v))
(let ((list '()))
  (s16vector-for-each
    (lambda (e) (set! list (cons e list)))
    s5)
  ;; stupid hack to shut up test egg about testing the value of a variable
  (test "for-each" '(5 4 3 2 1) (cons (car list) (cdr list))))
(let ((list '()))
  (s16vector-for-each
    (lambda (e1 e2) (set! list (cons (cons e1 e2) list)))
    s5
    (s16vector 6 7 8 9 10))
  ;; stupid hack to shut up test egg about testing the value of a variable
  (test "for-each" '((5 . 10) (4 . 9) (3 . 8) (2 . 7) (1 . 6))
        (cons (car list) (cdr list))))
(test "count" 3 (s16vector-count odd? s5))
(test "count" 2 (s16vector-count > s5 (s16vector 9 2 1 5 3)))
(test-equiv "cumulate" '(1 3 6 10 15)
            (s16vector-cumulate + 0 s5))

(test-equiv "take-while" '(1) (s16vector-take-while odd? s5))
(test-equiv "take-while-right" '(5) (s16vector-take-while-right odd? s5))
(test-equiv "drop-while" '(2 3 4 5) (s16vector-drop-while odd? s5))
(test-equiv "drop-while-right" '(1 2 3 4) (s16vector-drop-while-right odd? s5))
(test-equiv "degenerate take-while" '() (s16vector-take-while inexact? s5))
(test-equiv "degenerate take-while-right" '() (s16vector-take-while-right inexact? s5))
(test-equiv "degenerate drop-while" '(1 2 3 4 5) (s16vector-drop-while inexact? s5))
(test-equiv "degenerate drop-while-right" '(1 2 3 4 5) (s16vector-drop-while-right inexact? s5))
(test "index" 1 (s16vector-index even? s5))
(test "index" 2 (s16vector-index < s5 (s16vector 0 0 10 10 0)))
(test "index-right" 3 (s16vector-index-right even? s5))
(test "index-right" 3 (s16vector-index-right < s5 (s16vector 0 0 10 10 0)))
(test "skip" 1 (s16vector-skip odd? s5))
(test "skip" 2 (s16vector-skip > s5 (s16vector 0 0 10 10 0)))
(test "skip-right" 3 (s16vector-skip-right odd? s5))
(test "skip-right" 3 (s16vector-skip-right > s5 (s16vector 0 0 10 10 0)))
(test "any" 4 (s16vector-any (lambda (x) (and (even? x) (* x 2))) s5))
(test-assert "not any" (not (s16vector-any inexact? s5)))
(test "any + 1" 2 (s16vector-any odd+1 s5))
(test-assert "every" (s16vector-every exact? s5))
(test-assert "not every" (not (s16vector-every odd? s5)))
(test-assert "every + 1" (not (s16vector-every odd+1 s5)))
(test "multi-any" 10 (s16vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                              s5 (s16vector 0 1 2 6 4)))
(test "multi-any 2" #f (s16vector-any (lambda (x y) (and (even? x) (even? y) (+ x y)))
                              s5 (s16vector 0 1 2 5 4)))
(test "multi-every" 10 (s16vector-every (lambda (x) (and (exact? x) (* x 2))) s5))
(test "multi-every-2" 10 (s16vector-every (lambda (x y) (and (exact? x) (exact? y) (+ x y)))
                                  s5 s5))
(test-assert "multi-not every" (not (s16vector-every < s5 (s16vector 10 10 10 10 0))))
(test-equiv "partition" '(1 3 5 2 4)
            (call-with-values
                (lambda () (s16vector-partition odd? s5))
              (lambda (vec cnt) vec)))
(test-equiv "filter" '(1 3 5) (s16vector-filter odd? s5))
(test-equiv "remove" '(2 4) (s16vector-remove odd? s5))

(let ((v (s16vector 1 2 3)))
  ;(display "set!\n")
  (s16vector-set! v 0 10)
  (test-equiv "set!" '(10 2 3) v))
(let ((v (s16vector 1 2 3)))
  ;(display "swap!\n")
  (s16vector-swap! v 0 1)
  (test-equiv "swap!" '(2 1 3) v))
(let ((v (s16vector 1 2 3)))
  ;(display "fill!\n")
  (s16vector-fill! v 2)
  (test-equiv "fill!" '(2 2 2) v))
(let ((v (s16vector 1 2 3)))
  ;(display "fill2!\n")
  (s16vector-fill! v 10 0 2)
  (test-equiv "fill2!" '(10 10 3) v))
(let ((v (s16vector 1 2 3)))
  ;(display "reverse!\n")
  (s16vector-reverse! v)
  (test-equiv "reverse!" '(3 2 1) v))
(let ((v (s16vector 1 2 3)))
  ;(display "reverse!\n")
  (s16vector-reverse! v 1 3)
  (test-equiv "reverse2!" '(1 3 2) v))
(let ((v (s16vector 10 20 30 40 50)))
  ;(display "copy!\n")
  (s16vector-copy! v 1 s5 2 4)
  (test-equiv "copy!" '(10 3 4 40 50) v))
(let ((v (s16vector 10 20 30 40 50)))
  ;(display "reverse-copy!\n")
  (s16vector-reverse-copy! v 1 s5 2 4)
  (test-equiv "reverse-copy!" '(10 4 3 40 50) v))
(let ((v (s16vector 1 2 3 4 5 6 7 8)))
  ;(display "unfold!")
  (s16vector-unfold! (lambda (_ x) (values (* x 2) (* x 2))) v 1 6 -1)
  (test-equiv "vector-unfold!" '(1 -2 -4 -8 -16 -32 7 8) v))
(let ((v (s16vector 1 2 3 4 5 6 7 8)))
  ;(display "unfold-right!")
  (s16vector-unfold-right! (lambda (_ x) (values (* x 2) (* x 2))) v 1 6 -1)
  (test-equiv "vector-unfold!" '(1 -32 -16 -8 -4 -2 7 8) v))

(test "@vector->list 1" '(1 2 3 4 5)
      (s16vector->list s5))
(test "@vector->list 2" '(2 3 4 5)
      (s16vector->list s5 1))
(test "@vector->list 3" '(2 3 4)
      (s16vector->list s5 1 4))
(test "@vector->vector 1" #(1 2 3 4 5)
      (s16vector->vector s5))
(test "@vector->vector 2" #(2 3 4 5)
      (s16vector->vector s5 1))
(test "@vector->vector 3" #(2 3 4)
      (s16vector->vector s5 1 4))
(test-equiv "list->@vector" '(1 2 3 4 5)
            (list->s16vector '(1 2 3 4 5)))
(test-equiv "reverse-list->@vector" '(5 4 3 2 1)
            (reverse-list->s16vector '(1 2 3 4 5)))
(test-equiv "vector->@vector 1" '(1 2 3 4 5)
      (vector->s16vector #(1 2 3 4 5)))
(test-equiv "vector->@vector 2" '(2 3 4 5)
      (vector->s16vector #(1 2 3 4 5) 1))
(test-equiv "vector->@vector 3" '(2 3 4)
      (vector->s16vector #(1 2 3 4 5) 1 4))

(let ((port (open-output-string)))
  (write-s16vector s5 port)
  (test "write-@vector" "#s16(1 2 3 4 5)" (get-output-string port))
  (close-output-port port))

(test-assert "@vector< short" (s16vector< s4 s5))
(test-assert "not @vector< short" (not (s16vector< s5 s4)))
(test-assert "@vector< samelen" (s16vector< s5 s5+))
(test-assert "not @vector< samelen" (not (s16vector< s5+ s5+)))
(test-assert "@vector=" (s16vector= s5+ s5+))
(test-assert "@vector-hash" (fixnum? (s16vector-hash s5)))

(test "@vector-gen 0" 1 (g))
(test "@vector-gen 1" 2 (g))
(test "@vector-gen 2" 3 (g))
(test "@vector-gen 3" 4 (g))
(test "@vector-gen 4" 5 (g))
(test-assert (eof-object? (g)))

(test-end)

